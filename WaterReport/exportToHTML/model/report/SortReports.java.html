<html>
<head>
<title>SortReports.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(0,0,128); font-weight: bold; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(128,128,128); font-style: italic; }
.s3 { color: rgb(128,128,128); font-weight: bold; font-style: italic; }
.s4 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
SortReports.java</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">package </span><span class="s1">model.report; 
 
</span><span class="s0">import </span><span class="s1">java.util.ArrayList; 
</span><span class="s0">import </span><span class="s1">java.util.Collections; 
</span><span class="s0">import </span><span class="s1">java.util.HashSet; 
</span><span class="s0">import </span><span class="s1">java.util.Iterator; 
</span><span class="s0">import </span><span class="s1">java.util.LinkedList; 
</span><span class="s0">import </span><span class="s1">java.util.List; 
</span><span class="s0">import </span><span class="s1">java.util.Set; 
 
</span><span class="s2">/** 
 * Created by Alexandra on 10/12/2016. 
 * A class with utility methods, mostly regarding sorting Reports, which 
 * are taken from the ReportsList class. 
 */</span><span class="s1"> 
</span><span class="s0">public class </span><span class="s1">SortReports { 
    </span><span class="s0">private static </span><span class="s1">List&lt;Report&gt; reports; 
 
    </span><span class="s2">/** 
     * Updates @code reports by pulling from ReportsList 
     */</span><span class="s1"> 
    </span><span class="s0">private static void </span><span class="s1">updateReports() { 
        reports = ReportsList.getWaterReportsList(); 
        reports.addAll(ReportsList.getQualityReportsList()); 
 
        Iterator itr = reports.iterator(); 
        </span><span class="s0">while </span><span class="s1">(itr.hasNext()) { </span><span class="s2">// remove reports marked as delete</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">(((Report) itr.next()).getIsDeleted()) { 
                itr.remove(); 
            } 
        } 
    } 
 
    </span><span class="s2">/** 
     * Updates @code reports with non-deleted WaterReports 
     */</span><span class="s1"> 
    </span><span class="s0">private static void </span><span class="s1">updateWaterReports() { 
        reports = ReportsList.getWaterReportsList(); 
 
        Iterator itr = reports.iterator(); 
        </span><span class="s0">while </span><span class="s1">(itr.hasNext()) { </span><span class="s2">// don't sort reports that are deleted</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">(((Report) itr.next()).getIsDeleted()) { 
                itr.remove(); 
            } 
        } 
    } 
 
    </span><span class="s2">/** 
     * Updates @code reports with non-deleted QualityReports 
     */</span><span class="s1"> 
    </span><span class="s0">private static void </span><span class="s1">updateQualityReports() { 
        reports = ReportsList.getQualityReportsList(); 
 
        Iterator itr = reports.iterator(); 
        </span><span class="s0">while </span><span class="s1">(itr.hasNext()) { </span><span class="s2">// remove deleted reports</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">(((Report) itr.next()).getIsDeleted()) { 
                itr.remove(); 
            } 
        } 
    } 
 
    </span><span class="s2">/** 
     * Sorts all reports by their ReportID 
     * </span><span class="s3">@return </span><span class="s2">a copy  of a list sorted by their ReportID 
     */</span><span class="s1"> 
    </span><span class="s0">public static </span><span class="s1">List&lt;Report&gt; sortByReportID() { 
        updateReports(); 
        List&lt;Report&gt; reportClone = </span><span class="s0">new </span><span class="s1">ArrayList&lt;&gt;(reports); 
        Collections.sort(reportClone); 
        </span><span class="s0">return </span><span class="s1">reportClone; 
    } 
 
    </span><span class="s2">/** 
     * Sorts all reports by most recently added to oldest reports 
     * </span><span class="s3">@return </span><span class="s2">a copy of a list sorted by newest to oldest reports 
     */</span><span class="s1"> 
    </span><span class="s0">public static </span><span class="s1">List&lt;Report&gt; sortByMostRecent() { 
        updateReports(); 
        List&lt;Report&gt; reportClone = </span><span class="s0">new </span><span class="s1">ArrayList&lt;&gt;(reports); 
        Collections.sort(reportClone, (Report r1, Report r2) -&gt; 
                -</span><span class="s4">1 </span><span class="s1">* r1.getTimestamp().compareTo(r2.getTimestamp())); 
        </span><span class="s0">return </span><span class="s1">reportClone; 
    } 
 
    </span><span class="s2">/** 
     * Given a WaterType(s), returns a Set of all WaterReports that have 
     * at least one matching WaterType 
     * </span><span class="s3">@param </span><span class="s2">type one or more WaterTypes to filter by 
     * </span><span class="s3">@return </span><span class="s2">a Set of WaterReports of the desired WaterType(s) or an 
     * empty set if no WaterReports match 
     */</span><span class="s1"> 
    </span><span class="s0">public static </span><span class="s1">Set&lt;WaterReport&gt; filterByWaterType(WaterType ... type) { 
        updateWaterReports(); 
        Set&lt;WaterReport&gt; reportSet = </span><span class="s0">new </span><span class="s1">HashSet&lt;&gt;(); 
        </span><span class="s0">for </span><span class="s1">(Report r : reports) { 
            </span><span class="s0">boolean </span><span class="s1">added = </span><span class="s0">false</span><span class="s1">; 
            </span><span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; (i &lt; type.length) &amp;&amp; !added; i++) { 
                </span><span class="s2">// checks if the report's water type is a param</span><span class="s1"> 
                </span><span class="s0">if </span><span class="s1">(type[i].equals(((WaterReport)r).getWaterType())) { 
                    reportSet.add((WaterReport) r); 
                    added = </span><span class="s0">true</span><span class="s1">; 
                } 
            } 
        } 
        </span><span class="s0">return </span><span class="s1">reportSet; 
    } 
 
    </span><span class="s2">/** 
     * Given a WaterCondition(s), finds all WaterReports with at least one given 
     * WaterCondition(s) 
     * </span><span class="s3">@param </span><span class="s2">condition one or more WaterConditions to filter by 
     * </span><span class="s3">@return </span><span class="s2">a Set of all WaterReports of the desired WaterCondition(s) or 
     * an empty Set if no WaterReports match 
     */</span><span class="s1"> 
    </span><span class="s0">public static </span><span class="s1">Set&lt;WaterReport&gt; filterByWaterCondition(WaterCondition ... 
                                                                  condition) { 
        updateWaterReports(); 
        Set&lt;WaterReport&gt; reportSet = </span><span class="s0">new </span><span class="s1">HashSet&lt;&gt;(); 
        </span><span class="s0">for </span><span class="s1">(Report r : reports) { 
            </span><span class="s0">boolean </span><span class="s1">added = </span><span class="s0">false</span><span class="s1">; 
            </span><span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; (i &lt; condition.length) &amp;&amp; !added; i++) { 
                </span><span class="s2">// checks if the report's water condition is a param</span><span class="s1"> 
                </span><span class="s0">if </span><span class="s1">(condition[i].equals(((WaterReport) r).getWaterCondition())) { 
                    reportSet.add((WaterReport) r); 
                    added = </span><span class="s0">true</span><span class="s1">; </span><span class="s2">// exit innermost loop early</span><span class="s1"> 
                } 
            } 
        } 
        </span><span class="s0">return </span><span class="s1">reportSet; 
    } 
 
    </span><span class="s2">/** 
     * Given an OverallCondition(s), finds all QualityReports with at least one 
     * given conditions 
     * </span><span class="s3">@param </span><span class="s2">condition one or more OverallConditions to filter by 
     * </span><span class="s3">@return </span><span class="s2">a Set of all QualityReports of the desired OverallCondition(s) 
     * or an empty Set if no QualityReports match 
     */</span><span class="s1"> 
    </span><span class="s0">public static </span><span class="s1">Set&lt;QualityReport&gt; filterByOverallCondition( 
            OverallCondition ... condition) { 
        updateQualityReports(); 
        Set&lt;QualityReport&gt; reportSet = </span><span class="s0">new </span><span class="s1">HashSet&lt;&gt;(); 
        </span><span class="s0">for </span><span class="s1">(Report r : reports) { 
            </span><span class="s0">boolean </span><span class="s1">added = </span><span class="s0">false</span><span class="s1">; 
            </span><span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; (i &lt; condition.length) &amp;&amp; !added; i++) { 
                </span><span class="s0">if </span><span class="s1">(condition[i].equals(((QualityReport) r).getWaterCondition())) { 
                    reportSet.add((QualityReport) r); 
                    added = </span><span class="s0">true</span><span class="s1">; 
                } 
            } 
        } 
        </span><span class="s0">return </span><span class="s1">reportSet; 
    } 
 
    </span><span class="s2">/** 
     * Finds all WaterReports associated with a given Location(s) 
     * </span><span class="s3">@param </span><span class="s2">loc one or more Locations to filter by 
     * </span><span class="s3">@return </span><span class="s2">a List containing all WaterReports associated with @param loc 
     */</span><span class="s1"> 
    </span><span class="s0">public static </span><span class="s1">List&lt;WaterReport&gt; filterWaterReportsByLocation( 
            Location ... loc) { 
        updateWaterReports(); 
        List&lt;WaterReport&gt; waterReports = </span><span class="s0">new </span><span class="s1">ArrayList&lt;&gt;(); 
        </span><span class="s0">for </span><span class="s1">(Report r : reports) { 
            </span><span class="s0">boolean </span><span class="s1">added = </span><span class="s0">false</span><span class="s1">; 
            </span><span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; (i &lt; loc.length) &amp;&amp; !added; i++) { 
                </span><span class="s0">if </span><span class="s1">(loc[i].equals(r.getLocation())) { 
                    waterReports.add((WaterReport) r); 
                    added = </span><span class="s0">true</span><span class="s1">; </span><span class="s2">// prevents duplicates and exits</span><span class="s1"> 
                } 
            } 
        } 
        </span><span class="s0">return </span><span class="s1">waterReports; 
    } 
 
    </span><span class="s2">/** 
     * Finds all QualityReports associated with a given Location(s) 
     * </span><span class="s3">@param </span><span class="s2">loc one or more Locations to filter by 
     * </span><span class="s3">@return </span><span class="s2">a List containing all QualityReports associated with @param loc 
     */</span><span class="s1"> 
    </span><span class="s0">public static </span><span class="s1">List&lt;QualityReport&gt; filterQualityReportsByLocation( 
            Location ... loc) { 
        updateQualityReports(); 
        List&lt;QualityReport&gt; qualityReports = </span><span class="s0">new </span><span class="s1">ArrayList&lt;&gt;(); 
        </span><span class="s0">for </span><span class="s1">(Report r : reports) { 
            </span><span class="s0">boolean </span><span class="s1">added = </span><span class="s0">false</span><span class="s1">; 
            </span><span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; (i &lt; loc.length) &amp;&amp; !added; i++) { 
                </span><span class="s0">if </span><span class="s1">(loc[i].equals(r.getLocation())) { 
                    qualityReports.add((QualityReport) r); 
                    added = </span><span class="s0">true</span><span class="s1">; </span><span class="s2">// prevents duplicates and exits</span><span class="s1"> 
                } 
            } 
        } 
        </span><span class="s0">return </span><span class="s1">qualityReports; 
    } 
 
    </span><span class="s2">/** 
     * Finds all Reports associated with a given Location(s) 
     * </span><span class="s3">@param </span><span class="s2">loc one or more Locations to filter by 
     * </span><span class="s3">@return </span><span class="s2">a List containing all Reports associated with @param loc 
     */</span><span class="s1"> 
    </span><span class="s0">public static </span><span class="s1">List&lt;Report&gt; filterReportsByLocation(Location ... loc) { 
        updateReports(); 
        List&lt;Report&gt; reports = 
                </span><span class="s0">new </span><span class="s1">LinkedList&lt;&gt;(filterWaterReportsByLocation(loc)); 
        reports.addAll(filterQualityReportsByLocation(loc)); 
        </span><span class="s0">return </span><span class="s1">reports; 
    } 
 
    </span><span class="s2">/** 
     * Calculates the average virusPPM per month, where each month 
     * is denoted by the array index 
     * [0] January, [1] February, ... [11] December 
     * </span><span class="s3">@param </span><span class="s2">loc the Location for which to generate data 
     * </span><span class="s3">@param </span><span class="s2">radius the radius in miles that a Location must be relative 
     * to loc to be included in the HistoricalReport 
     * </span><span class="s3">@param </span><span class="s2">year the desired year 
     * </span><span class="s3">@return </span><span class="s2">a double[] containing the average virusPPM per month 
     */</span><span class="s1"> 
    </span><span class="s0">public static double</span><span class="s1">[] generateHistoricalReportByVirusPPM( 
            Location loc, </span><span class="s0">double </span><span class="s1">radius, </span><span class="s0">int </span><span class="s1">year) { 
        updateQualityReports(); 
        </span><span class="s0">final int </span><span class="s1">MONTHS = </span><span class="s4">12</span><span class="s1">; 
        </span><span class="s2">// There is no way to resolve this unchecked cast since Java</span><span class="s1"> 
        </span><span class="s2">// does not allow instantiation of generic arrays.</span><span class="s1"> 
        </span><span class="s2">// The &quot;magic number&quot; 12 is because there are 12 months in a year.</span><span class="s1"> 
        List&lt;Double&gt;[] reportsByMonth = (List&lt;Double&gt;[]) </span><span class="s0">new </span><span class="s1">List[MONTHS]; 
 
        </span><span class="s2">//noinspection Convert2streamapi</span><span class="s1"> 
        </span><span class="s0">for </span><span class="s1">(Report r : reports) { 
            </span><span class="s0">if </span><span class="s1">((Location.calculateDistance(loc, r.getLocation()) &lt;= radius) 
                    &amp;&amp; (r.getTimestamp().getYear() == year)) { 
                </span><span class="s2">// check against params</span><span class="s1"> 
                </span><span class="s0">int </span><span class="s1">index = r.getTimestamp().getMonthValue() - </span><span class="s4">1</span><span class="s1">; 
                </span><span class="s0">if </span><span class="s1">(reportsByMonth[index] == </span><span class="s0">null</span><span class="s1">) { 
                    reportsByMonth[index] = </span><span class="s0">new </span><span class="s1">ArrayList&lt;&gt;(); 
                } 
                reportsByMonth[index].add(((QualityReport) r) 
                        .getVirusPPM()); 
            } 
        } 
 
        </span><span class="s0">return </span><span class="s1">getAverage(reportsByMonth); 
    } 
 
    </span><span class="s2">/** 
     * Calculates the average contaminant per month, where each month 
     * is denoted by the array index 
     * [0] January, [1] February, ... [11] December 
     * </span><span class="s3">@param </span><span class="s2">loc the Location for which to generate data 
     * </span><span class="s3">@param </span><span class="s2">radius the radius in miles that a Location must be relative 
     * to loc to be included in the HistoricalReport 
     * </span><span class="s3">@param </span><span class="s2">year the desired year 
     * </span><span class="s3">@return </span><span class="s2">a double[] containing the average contaminantPPM per month 
     */</span><span class="s1"> 
    </span><span class="s0">public static double</span><span class="s1">[] generateHistoricalReportByContaminantPPM( 
            Location loc, </span><span class="s0">double </span><span class="s1">radius, </span><span class="s0">int </span><span class="s1">year) { 
        updateQualityReports(); 
        </span><span class="s0">final int </span><span class="s1">MONTHS = </span><span class="s4">12</span><span class="s1">; 
        </span><span class="s2">// There is no way to resolve this unchecked cast since Java</span><span class="s1"> 
        </span><span class="s2">// does not allow instantiation of generic arrays.</span><span class="s1"> 
        </span><span class="s2">// The &quot;magic number&quot; 12 is because there are 12 months in a year.</span><span class="s1"> 
        List&lt;Double&gt;[] reportsByMonth = (List&lt;Double&gt;[]) </span><span class="s0">new </span><span class="s1">List[MONTHS]; 
 
        </span><span class="s2">//noinspection Convert2streamapi</span><span class="s1"> 
        </span><span class="s0">for </span><span class="s1">(Report r : reports) { 
            </span><span class="s0">if </span><span class="s1">((Location.calculateDistance(loc, r.getLocation()) &lt;= radius) 
                    &amp;&amp; (r.getTimestamp().getYear() == year)) { 
                </span><span class="s2">// check against params</span><span class="s1"> 
                </span><span class="s0">int </span><span class="s1">index = r.getTimestamp().getMonthValue() - </span><span class="s4">1</span><span class="s1">; 
                </span><span class="s0">if </span><span class="s1">(reportsByMonth[index] == </span><span class="s0">null</span><span class="s1">) { 
                    reportsByMonth[index] = </span><span class="s0">new </span><span class="s1">ArrayList&lt;&gt;(); 
                } 
                reportsByMonth[index].add(((QualityReport) r) 
                        .getContaminantPPM()); 
            } 
        } 
 
        </span><span class="s0">return </span><span class="s1">getAverage(reportsByMonth); 
    } 
 
    </span><span class="s0">private static double</span><span class="s1">[] getAverage(List&lt;Double&gt;[] reportsByMonth) { 
        </span><span class="s0">double</span><span class="s1">[] AveragePPMByMonth = </span><span class="s0">new double</span><span class="s1">[reportsByMonth.length]; 
        </span><span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; reportsByMonth.length; i++) { 
            </span><span class="s0">double </span><span class="s1">sum = </span><span class="s4">0</span><span class="s1">; 
            </span><span class="s0">if </span><span class="s1">(reportsByMonth[i] == </span><span class="s0">null</span><span class="s1">) { 
                AveragePPMByMonth[i] = sum; 
            } </span><span class="s0">else </span><span class="s1">{ 
                </span><span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">; j &lt; reportsByMonth[i].size(); j++) { 
                    sum += reportsByMonth[i].get(j); 
                } 
                AveragePPMByMonth[i] = sum / reportsByMonth[i].size(); 
            } 
        } 
        </span><span class="s0">return </span><span class="s1">AveragePPMByMonth; 
    } 
} 
</span></pre>
</body>
</html>