<html>
<head>
<title>PasswordStorage.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(0,0,128); font-weight: bold; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(0,128,0); font-weight: bold; }
.s3 { color: rgb(128,128,128); font-style: italic; }
.s4 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
PasswordStorage.java</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">package </span><span class="s1">lib.password_hashing; 
 
</span><span class="s0">import </span><span class="s1">java.security.SecureRandom; 
</span><span class="s0">import </span><span class="s1">javax.crypto.spec.PBEKeySpec; 
</span><span class="s0">import </span><span class="s1">javax.crypto.SecretKeyFactory; 
</span><span class="s0">import </span><span class="s1">java.math.BigInteger; 
</span><span class="s0">import </span><span class="s1">java.security.NoSuchAlgorithmException; 
</span><span class="s0">import </span><span class="s1">java.security.spec.InvalidKeySpecException; 
</span><span class="s0">import </span><span class="s1">javax.xml.bind.DatatypeConverter; 
 
</span><span class="s0">public class </span><span class="s1">PasswordStorage 
{ 
 
    @SuppressWarnings(</span><span class="s2">&quot;serial&quot;</span><span class="s1">) 
    </span><span class="s0">static public class </span><span class="s1">InvalidHashException </span><span class="s0">extends </span><span class="s1">Exception { 
        </span><span class="s0">public </span><span class="s1">InvalidHashException(String message) { 
            </span><span class="s0">super</span><span class="s1">(message); 
        } 
        </span><span class="s0">public </span><span class="s1">InvalidHashException(String message, Throwable source) { 
            </span><span class="s0">super</span><span class="s1">(message, source); 
        } 
    } 
 
    @SuppressWarnings(</span><span class="s2">&quot;serial&quot;</span><span class="s1">) 
    </span><span class="s0">static public class </span><span class="s1">CannotPerformOperationException </span><span class="s0">extends </span><span class="s1">Exception { 
        </span><span class="s0">public </span><span class="s1">CannotPerformOperationException(String message) { 
            </span><span class="s0">super</span><span class="s1">(message); 
        } 
        </span><span class="s0">public </span><span class="s1">CannotPerformOperationException(String message, Throwable source) { 
            </span><span class="s0">super</span><span class="s1">(message, source); 
        } 
    } 
 
    </span><span class="s0">public static final </span><span class="s1">String PBKDF2_ALGORITHM = </span><span class="s2">&quot;PBKDF2WithHmacSHA1&quot;</span><span class="s1">; 
 
    </span><span class="s3">// These constants may be changed without breaking existing hashes.</span><span class="s1"> 
    </span><span class="s0">public static final int </span><span class="s1">SALT_BYTE_SIZE = </span><span class="s4">24</span><span class="s1">; 
    </span><span class="s0">public static final int </span><span class="s1">HASH_BYTE_SIZE = </span><span class="s4">18</span><span class="s1">; 
    </span><span class="s0">public static final int </span><span class="s1">PBKDF2_ITERATIONS = </span><span class="s4">64000</span><span class="s1">; 
 
    </span><span class="s3">// These constants define the encoding and may not be changed.</span><span class="s1"> 
    </span><span class="s0">public static final int </span><span class="s1">HASH_SECTIONS = </span><span class="s4">5</span><span class="s1">; 
    </span><span class="s0">public static final int </span><span class="s1">HASH_ALGORITHM_INDEX = </span><span class="s4">0</span><span class="s1">; 
    </span><span class="s0">public static final int </span><span class="s1">ITERATION_INDEX = </span><span class="s4">1</span><span class="s1">; 
    </span><span class="s0">public static final int </span><span class="s1">HASH_SIZE_INDEX = </span><span class="s4">2</span><span class="s1">; 
    </span><span class="s0">public static final int </span><span class="s1">SALT_INDEX = </span><span class="s4">3</span><span class="s1">; 
    </span><span class="s0">public static final int </span><span class="s1">PBKDF2_INDEX = </span><span class="s4">4</span><span class="s1">; 
 
    </span><span class="s0">public static </span><span class="s1">String createHash(String password) 
        </span><span class="s0">throws </span><span class="s1">CannotPerformOperationException 
    { 
        </span><span class="s0">return </span><span class="s1">createHash(password.toCharArray()); 
    } 
 
    </span><span class="s0">public static </span><span class="s1">String createHash(</span><span class="s0">char</span><span class="s1">[] password) 
        </span><span class="s0">throws </span><span class="s1">CannotPerformOperationException 
    { 
        </span><span class="s3">// Generate a random salt</span><span class="s1"> 
        SecureRandom random = </span><span class="s0">new </span><span class="s1">SecureRandom(); 
        </span><span class="s0">byte</span><span class="s1">[] salt = </span><span class="s0">new byte</span><span class="s1">[SALT_BYTE_SIZE]; 
        random.nextBytes(salt); 
 
        </span><span class="s3">// Hash the password</span><span class="s1"> 
        </span><span class="s0">byte</span><span class="s1">[] hash = pbkdf2(password, salt, PBKDF2_ITERATIONS, HASH_BYTE_SIZE); 
        </span><span class="s0">int </span><span class="s1">hashSize = hash.length; 
 
        </span><span class="s3">// format: algorithm:iterations:hashSize:salt:hash</span><span class="s1"> 
        String parts = </span><span class="s2">&quot;sha1:&quot; </span><span class="s1">+ 
            PBKDF2_ITERATIONS + 
            </span><span class="s2">&quot;:&quot; </span><span class="s1">+ hashSize + 
            </span><span class="s2">&quot;:&quot; </span><span class="s1">+ 
            toBase64(salt) + 
            </span><span class="s2">&quot;:&quot; </span><span class="s1">+ 
            toBase64(hash); 
        </span><span class="s0">return </span><span class="s1">parts; 
    } 
 
    </span><span class="s0">public static boolean </span><span class="s1">verifyPassword(String password, String correctHash) 
        </span><span class="s0">throws </span><span class="s1">CannotPerformOperationException, InvalidHashException 
    { 
        </span><span class="s0">return </span><span class="s1">verifyPassword(password.toCharArray(), correctHash); 
    } 
 
    </span><span class="s0">public static boolean </span><span class="s1">verifyPassword(</span><span class="s0">char</span><span class="s1">[] password, String correctHash) 
        </span><span class="s0">throws </span><span class="s1">CannotPerformOperationException, InvalidHashException 
    { 
        </span><span class="s3">// Decode the hash into its parameters</span><span class="s1"> 
        String[] params = correctHash.split(</span><span class="s2">&quot;:&quot;</span><span class="s1">); 
        </span><span class="s0">if </span><span class="s1">(params.length != HASH_SECTIONS) { 
            </span><span class="s0">throw new </span><span class="s1">InvalidHashException( 
                </span><span class="s2">&quot;Fields are missing from the password hash.&quot;</span><span class="s1"> 
            ); 
        } 
 
        </span><span class="s3">// Currently, Java only supports SHA1.</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">(!params[HASH_ALGORITHM_INDEX].equals(</span><span class="s2">&quot;sha1&quot;</span><span class="s1">)) { 
            </span><span class="s0">throw new </span><span class="s1">CannotPerformOperationException( 
                </span><span class="s2">&quot;Unsupported hash type.&quot;</span><span class="s1"> 
            ); 
        } 
 
        </span><span class="s0">int </span><span class="s1">iterations = </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s0">try </span><span class="s1">{ 
            iterations = Integer.parseInt(params[ITERATION_INDEX]); 
        } </span><span class="s0">catch </span><span class="s1">(NumberFormatException ex) { 
            </span><span class="s0">throw new </span><span class="s1">InvalidHashException( 
                </span><span class="s2">&quot;Could not parse the iteration count as an integer.&quot;</span><span class="s1">, 
                ex 
            ); 
        } 
 
        </span><span class="s0">if </span><span class="s1">(iterations &lt; </span><span class="s4">1</span><span class="s1">) { 
            </span><span class="s0">throw new </span><span class="s1">InvalidHashException( 
                </span><span class="s2">&quot;Invalid number of iterations. Must be &gt;= 1.&quot;</span><span class="s1"> 
            ); 
        } 
 
 
        </span><span class="s0">byte</span><span class="s1">[] salt = </span><span class="s0">null</span><span class="s1">; 
        </span><span class="s0">try </span><span class="s1">{ 
            salt = fromBase64(params[SALT_INDEX]); 
        } </span><span class="s0">catch </span><span class="s1">(IllegalArgumentException ex) { 
            </span><span class="s0">throw new </span><span class="s1">InvalidHashException( 
                </span><span class="s2">&quot;Base64 decoding of salt failed.&quot;</span><span class="s1">, 
                ex 
            ); 
        } 
 
        </span><span class="s0">byte</span><span class="s1">[] hash = </span><span class="s0">null</span><span class="s1">; 
        </span><span class="s0">try </span><span class="s1">{ 
            hash = fromBase64(params[PBKDF2_INDEX]); 
        } </span><span class="s0">catch </span><span class="s1">(IllegalArgumentException ex) { 
            </span><span class="s0">throw new </span><span class="s1">InvalidHashException( 
                </span><span class="s2">&quot;Base64 decoding of pbkdf2 output failed.&quot;</span><span class="s1">, 
                ex 
            ); 
        } 
 
 
        </span><span class="s0">int </span><span class="s1">storedHashSize = </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s0">try </span><span class="s1">{ 
            storedHashSize = Integer.parseInt(params[HASH_SIZE_INDEX]); 
        } </span><span class="s0">catch </span><span class="s1">(NumberFormatException ex) { 
            </span><span class="s0">throw new </span><span class="s1">InvalidHashException( 
                </span><span class="s2">&quot;Could not parse the hash size as an integer.&quot;</span><span class="s1">, 
                ex 
            ); 
        } 
 
        </span><span class="s0">if </span><span class="s1">(storedHashSize != hash.length) { 
            </span><span class="s0">throw new </span><span class="s1">InvalidHashException( 
                </span><span class="s2">&quot;Hash length doesn't match stored hash length.&quot;</span><span class="s1"> 
            ); 
        } 
 
        </span><span class="s3">// Compute the hash of the provided password, using the same salt, </span><span class="s1"> 
        </span><span class="s3">// iteration count, and hash length</span><span class="s1"> 
        </span><span class="s0">byte</span><span class="s1">[] testHash = pbkdf2(password, salt, iterations, hash.length); 
        </span><span class="s3">// Compare the hashes in constant time. The password is correct if</span><span class="s1"> 
        </span><span class="s3">// both hashes match.</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">slowEquals(hash, testHash); 
    } 
 
    </span><span class="s0">private static boolean </span><span class="s1">slowEquals(</span><span class="s0">byte</span><span class="s1">[] a, </span><span class="s0">byte</span><span class="s1">[] b) 
    { 
        </span><span class="s0">int </span><span class="s1">diff = a.length ^ b.length; 
        </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; a.length &amp;&amp; i &lt; b.length; i++) 
            diff |= a[i] ^ b[i]; 
        </span><span class="s0">return </span><span class="s1">diff == </span><span class="s4">0</span><span class="s1">; 
    } 
 
    </span><span class="s0">private static byte</span><span class="s1">[] pbkdf2(</span><span class="s0">char</span><span class="s1">[] password, </span><span class="s0">byte</span><span class="s1">[] salt, </span><span class="s0">int </span><span class="s1">iterations, </span><span class="s0">int </span><span class="s1">bytes) 
        </span><span class="s0">throws </span><span class="s1">CannotPerformOperationException 
    { 
        </span><span class="s0">try </span><span class="s1">{ 
            PBEKeySpec spec = </span><span class="s0">new </span><span class="s1">PBEKeySpec(password, salt, iterations, bytes * </span><span class="s4">8</span><span class="s1">); 
            SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM); 
            </span><span class="s0">return </span><span class="s1">skf.generateSecret(spec).getEncoded(); 
        } </span><span class="s0">catch </span><span class="s1">(NoSuchAlgorithmException ex) { 
            </span><span class="s0">throw new </span><span class="s1">CannotPerformOperationException( 
                </span><span class="s2">&quot;Hash algorithm not supported.&quot;</span><span class="s1">, 
                ex 
            ); 
        } </span><span class="s0">catch </span><span class="s1">(InvalidKeySpecException ex) { 
            </span><span class="s0">throw new </span><span class="s1">CannotPerformOperationException( 
                </span><span class="s2">&quot;Invalid key spec.&quot;</span><span class="s1">, 
                ex 
            ); 
        } 
    } 
 
    </span><span class="s0">private static byte</span><span class="s1">[] fromBase64(String hex) 
        </span><span class="s0">throws </span><span class="s1">IllegalArgumentException 
    { 
        </span><span class="s0">return </span><span class="s1">DatatypeConverter.parseBase64Binary(hex); 
    } 
 
    </span><span class="s0">private static </span><span class="s1">String toBase64(</span><span class="s0">byte</span><span class="s1">[] array) 
    { 
        </span><span class="s0">return </span><span class="s1">DatatypeConverter.printBase64Binary(array); 
    } 
 
} 
</span></pre>
</body>
</html>