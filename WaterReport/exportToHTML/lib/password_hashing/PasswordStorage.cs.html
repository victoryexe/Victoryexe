<html>
<head>
<title>PasswordStorage.cs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(0,0,0); }
.s1 { color: rgb(0,0,128); font-weight: bold; }
.s2 { color: rgb(128,128,128); font-style: italic; }
.s3 { color: rgb(0,0,255); }
.s4 { color: rgb(0,128,0); font-weight: bold; }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
PasswordStorage.cs</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0"> 
</span><span class="s1">using </span><span class="s0">System; 
</span><span class="s1">using </span><span class="s0">System.Text; 
</span><span class="s1">using </span><span class="s0">System.Security.Cryptography; 
 
</span><span class="s1">namespace </span><span class="s0">PasswordSecurity 
{ 
    </span><span class="s1">class </span><span class="s0">InvalidHashException : Exception 
    { 
        </span><span class="s1">public </span><span class="s0">InvalidHashException() { } 
        </span><span class="s1">public </span><span class="s0">InvalidHashException(</span><span class="s1">string </span><span class="s0">message) 
            : </span><span class="s1">base</span><span class="s0">(message) { } 
        </span><span class="s1">public </span><span class="s0">InvalidHashException(</span><span class="s1">string </span><span class="s0">message, Exception inner) 
            : </span><span class="s1">base</span><span class="s0">(message, inner) { } 
    } 
 
    </span><span class="s1">class </span><span class="s0">CannotPerformOperationException : Exception 
    { 
        </span><span class="s1">public </span><span class="s0">CannotPerformOperationException() { } 
        </span><span class="s1">public </span><span class="s0">CannotPerformOperationException(</span><span class="s1">string </span><span class="s0">message) 
            : </span><span class="s1">base</span><span class="s0">(message) { } 
        </span><span class="s1">public </span><span class="s0">CannotPerformOperationException(</span><span class="s1">string </span><span class="s0">message, Exception inner) 
            : </span><span class="s1">base</span><span class="s0">(message, inner) { } 
    } 
 
    </span><span class="s1">class </span><span class="s0">PasswordStorage 
    { 
        </span><span class="s2">// These constants may be changed without breaking existing hashes.</span><span class="s0"> 
        </span><span class="s1">public const int </span><span class="s0">SALT_BYTES = </span><span class="s3">24</span><span class="s0">; 
        </span><span class="s1">public const int </span><span class="s0">HASH_BYTES = </span><span class="s3">18</span><span class="s0">; 
        </span><span class="s1">public const int </span><span class="s0">PBKDF2_ITERATIONS = </span><span class="s3">64000</span><span class="s0">; 
 
        </span><span class="s2">// These constants define the encoding and may not be changed.</span><span class="s0"> 
        </span><span class="s1">public const int </span><span class="s0">HASH_SECTIONS = </span><span class="s3">5</span><span class="s0">; 
        </span><span class="s1">public const int </span><span class="s0">HASH_ALGORITHM_INDEX = </span><span class="s3">0</span><span class="s0">; 
        </span><span class="s1">public const int </span><span class="s0">ITERATION_INDEX = </span><span class="s3">1</span><span class="s0">; 
        </span><span class="s1">public const int </span><span class="s0">HASH_SIZE_INDEX = </span><span class="s3">2</span><span class="s0">; 
        </span><span class="s1">public const int </span><span class="s0">SALT_INDEX = </span><span class="s3">3</span><span class="s0">; 
        </span><span class="s1">public const int </span><span class="s0">PBKDF2_INDEX = </span><span class="s3">4</span><span class="s0">; 
 
        </span><span class="s1">public static string </span><span class="s0">CreateHash(</span><span class="s1">string </span><span class="s0">password) 
        { 
            </span><span class="s2">// Generate a random salt</span><span class="s0"> 
            </span><span class="s1">byte</span><span class="s0">[] salt = </span><span class="s1">new byte</span><span class="s0">[SALT_BYTES]; 
            </span><span class="s1">try </span><span class="s0">{ 
                </span><span class="s1">using </span><span class="s0">(RNGCryptoServiceProvider csprng = </span><span class="s1">new </span><span class="s0">RNGCryptoServiceProvider()) { 
                        csprng.GetBytes(salt); 
                } 
            } </span><span class="s1">catch </span><span class="s0">(CryptographicException ex) { 
                </span><span class="s1">throw new </span><span class="s0">CannotPerformOperationException( 
                    </span><span class="s4">&quot;Random number generator not available.&quot;</span><span class="s0">, 
                    ex 
                ); 
            } </span><span class="s1">catch </span><span class="s0">(ArgumentNullException ex) { 
                </span><span class="s1">throw new </span><span class="s0">CannotPerformOperationException( 
                    </span><span class="s4">&quot;Invalid argument given to random number generator.&quot;</span><span class="s0">, 
                    ex 
                ); 
            } 
 
            </span><span class="s1">byte</span><span class="s0">[] hash = PBKDF2(password, salt, PBKDF2_ITERATIONS, HASH_BYTES); 
 
            </span><span class="s2">// format: algorithm:iterations:hashSize:salt:hash</span><span class="s0"> 
            String parts = </span><span class="s4">&quot;sha1:&quot; </span><span class="s0">+ 
                PBKDF2_ITERATIONS + 
                </span><span class="s4">&quot;:&quot; </span><span class="s0">+ 
                hash.Length + 
                </span><span class="s4">&quot;:&quot; </span><span class="s0">+ 
                Convert.ToBase64String(salt) + 
                </span><span class="s4">&quot;:&quot; </span><span class="s0">+ 
                Convert.ToBase64String(hash); 
            </span><span class="s1">return </span><span class="s0">parts; 
        } 
 
        </span><span class="s1">public static bool </span><span class="s0">VerifyPassword(</span><span class="s1">string </span><span class="s0">password, </span><span class="s1">string </span><span class="s0">goodHash) 
        { 
            </span><span class="s1">char</span><span class="s0">[] delimiter = { </span><span class="s4">':' </span><span class="s0">}; 
            </span><span class="s1">string</span><span class="s0">[] split = goodHash.Split(delimiter); 
 
            </span><span class="s1">if </span><span class="s0">(split.Length != HASH_SECTIONS) { 
                </span><span class="s1">throw new </span><span class="s0">InvalidHashException( 
                    </span><span class="s4">&quot;Fields are missing from the password hash.&quot;</span><span class="s0"> 
                ); 
            } 
 
            </span><span class="s2">// We only support SHA1 with C#.</span><span class="s0"> 
            </span><span class="s1">if </span><span class="s0">(split[HASH_ALGORITHM_INDEX] != </span><span class="s4">&quot;sha1&quot;</span><span class="s0">) { 
                </span><span class="s1">throw new </span><span class="s0">CannotPerformOperationException( 
                    </span><span class="s4">&quot;Unsupported hash type.&quot;</span><span class="s0"> 
                ); 
            } 
 
            </span><span class="s1">int </span><span class="s0">iterations = </span><span class="s3">0</span><span class="s0">; 
            </span><span class="s1">try </span><span class="s0">{ 
                iterations = Int32.Parse(split[ITERATION_INDEX]); 
            } </span><span class="s1">catch </span><span class="s0">(ArgumentNullException ex) { 
                </span><span class="s1">throw new </span><span class="s0">CannotPerformOperationException( 
                    </span><span class="s4">&quot;Invalid argument given to Int32.Parse&quot;</span><span class="s0">, 
                    ex 
                ); 
            } </span><span class="s1">catch </span><span class="s0">(FormatException ex) { 
                </span><span class="s1">throw new </span><span class="s0">InvalidHashException( 
                    </span><span class="s4">&quot;Could not parse the iteration count as an integer.&quot;</span><span class="s0">, 
                    ex 
                ); 
            } </span><span class="s1">catch </span><span class="s0">(OverflowException ex) { 
                </span><span class="s1">throw new </span><span class="s0">InvalidHashException( 
                    </span><span class="s4">&quot;The iteration count is too large to be represented.&quot;</span><span class="s0">, 
                    ex 
                ); 
            } 
 
            </span><span class="s1">if </span><span class="s0">(iterations &lt; </span><span class="s3">1</span><span class="s0">) { 
                </span><span class="s1">throw new </span><span class="s0">InvalidHashException( 
                    </span><span class="s4">&quot;Invalid number of iterations. Must be &gt;= 1.&quot;</span><span class="s0"> 
                ); 
            } 
 
            </span><span class="s1">byte</span><span class="s0">[] salt = </span><span class="s1">null</span><span class="s0">; 
            </span><span class="s1">try </span><span class="s0">{ 
                salt = Convert.FromBase64String(split[SALT_INDEX]); 
            } 
            </span><span class="s1">catch </span><span class="s0">(ArgumentNullException ex) { 
                </span><span class="s1">throw new </span><span class="s0">CannotPerformOperationException( 
                    </span><span class="s4">&quot;Invalid argument given to Convert.FromBase64String&quot;</span><span class="s0">, 
                    ex 
                ); 
            } </span><span class="s1">catch </span><span class="s0">(FormatException ex) { 
                </span><span class="s1">throw new </span><span class="s0">InvalidHashException( 
                    </span><span class="s4">&quot;Base64 decoding of salt failed.&quot;</span><span class="s0">, 
                    ex 
                ); 
            } 
 
            </span><span class="s1">byte</span><span class="s0">[] hash = </span><span class="s1">null</span><span class="s0">; 
            </span><span class="s1">try </span><span class="s0">{ 
                hash = Convert.FromBase64String(split[PBKDF2_INDEX]); 
            } 
            </span><span class="s1">catch </span><span class="s0">(ArgumentNullException ex) { 
                </span><span class="s1">throw new </span><span class="s0">CannotPerformOperationException( 
                    </span><span class="s4">&quot;Invalid argument given to Convert.FromBase64String&quot;</span><span class="s0">, 
                    ex 
                ); 
            } </span><span class="s1">catch </span><span class="s0">(FormatException ex) { 
                </span><span class="s1">throw new </span><span class="s0">InvalidHashException( 
                    </span><span class="s4">&quot;Base64 decoding of pbkdf2 output failed.&quot;</span><span class="s0">, 
                    ex 
                ); 
            } 
 
            </span><span class="s1">int </span><span class="s0">storedHashSize = </span><span class="s3">0</span><span class="s0">; 
            </span><span class="s1">try </span><span class="s0">{ 
                storedHashSize = Int32.Parse(split[HASH_SIZE_INDEX]); 
            } </span><span class="s1">catch </span><span class="s0">(ArgumentNullException ex) { 
                </span><span class="s1">throw new </span><span class="s0">CannotPerformOperationException( 
                    </span><span class="s4">&quot;Invalid argument given to Int32.Parse&quot;</span><span class="s0">, 
                    ex 
                ); 
            } </span><span class="s1">catch </span><span class="s0">(FormatException ex) { 
                </span><span class="s1">throw new </span><span class="s0">InvalidHashException( 
                    </span><span class="s4">&quot;Could not parse the hash size as an integer.&quot;</span><span class="s0">, 
                    ex 
                ); 
            } </span><span class="s1">catch </span><span class="s0">(OverflowException ex) { 
                </span><span class="s1">throw new </span><span class="s0">InvalidHashException( 
                    </span><span class="s4">&quot;The hash size is too large to be represented.&quot;</span><span class="s0">, 
                    ex 
                ); 
            } 
 
            </span><span class="s1">if </span><span class="s0">(storedHashSize != hash.Length) { 
                </span><span class="s1">throw new </span><span class="s0">InvalidHashException( 
                    </span><span class="s4">&quot;Hash length doesn't match stored hash length.&quot;</span><span class="s0"> 
                ); 
            } 
 
            </span><span class="s1">byte</span><span class="s0">[] testHash = PBKDF2(password, salt, iterations, hash.Length); 
            </span><span class="s1">return </span><span class="s0">SlowEquals(hash, testHash); 
        } 
 
        </span><span class="s1">private static bool </span><span class="s0">SlowEquals(</span><span class="s1">byte</span><span class="s0">[] a, </span><span class="s1">byte</span><span class="s0">[] b) 
        { 
            </span><span class="s1">uint </span><span class="s0">diff = (</span><span class="s1">uint</span><span class="s0">)a.Length ^ (</span><span class="s1">uint</span><span class="s0">)b.Length; 
            </span><span class="s1">for </span><span class="s0">(</span><span class="s1">int </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; a.Length &amp;&amp; i &lt; b.Length; i++) { 
                diff |= (</span><span class="s1">uint</span><span class="s0">)(a[i] ^ b[i]); 
            } 
            </span><span class="s1">return </span><span class="s0">diff == </span><span class="s3">0</span><span class="s0">; 
        } 
 
        </span><span class="s1">private static byte</span><span class="s0">[] PBKDF2(</span><span class="s1">string </span><span class="s0">password, </span><span class="s1">byte</span><span class="s0">[] salt, </span><span class="s1">int </span><span class="s0">iterations, </span><span class="s1">int </span><span class="s0">outputBytes) 
        { 
            </span><span class="s1">using </span><span class="s0">(Rfc2898DeriveBytes pbkdf2 = </span><span class="s1">new </span><span class="s0">Rfc2898DeriveBytes(password, salt)) { 
                pbkdf2.IterationCount = iterations; 
                </span><span class="s1">return </span><span class="s0">pbkdf2.GetBytes(outputBytes); 
            } 
        } 
    } 
} 
 
</span></pre>
</body>
</html>