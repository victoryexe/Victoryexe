<html>
<head>
<title>test.php</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(0,0,0); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
test.php</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&lt;?php 
/*  
 * Password Hashing With PBKDF2 (http://crackstation.net/hashing-security.htm). 
 * Copyright (c) 2013, Taylor Hornby 
 * All rights reserved. 
 * 
 * Redistribution and use in source and binary forms, with or without  
 * modification, are permitted provided that the following conditions are met: 
 * 
 * 1. Redistributions of source code must retain the above copyright notice,  
 * this list of conditions and the following disclaimer. 
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation  
 * and/or other materials provided with the distribution. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  
 * POSSIBILITY OF SUCH DAMAGE. 
 */ 
require_once('PasswordStorage.php'); 
 
if (test()) { 
    exit(0); 
} else { 
    exit(1); 
} 
 
 
function test() 
{ 
    $all_tests_pass = true; 
 
    // Test vector raw output. 
    $a = bin2hex(PasswordStorage::pbkdf2(&quot;sha1&quot;, &quot;password&quot;, &quot;salt&quot;, 2, 20, true)); 
    $b = &quot;ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957&quot;; 
    if ($a === $b) { 
        echo &quot;Test vector 1: pass\n&quot;; 
    } else {  
        echo &quot;Test vector 1: FAIL\n&quot;; 
        $all_tests_pass = false; 
    } 
 
    // Test vector hex output. 
    $a = PasswordStorage::pbkdf2(&quot;sha1&quot;, &quot;password&quot;, &quot;salt&quot;, 2, 20, false); 
    $b = &quot;ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957&quot;; 
    if ($a === $b) { 
        echo &quot;Test vector 2: pass\n&quot;; 
    } else {  
        echo &quot;Test vector 2: FAIL\n&quot;; 
        $all_tests_pass = false; 
    } 
 
    $correct_password = &quot;correct_password&quot;; 
 
    $hash = PasswordStorage::create_hash($correct_password); 
 
    // Right password returns true. 
    $result = PasswordStorage::verify_password($correct_password, $hash); 
    if ($result === TRUE) 
    { 
        echo &quot;Correct password: pass\n&quot;; 
    } 
    else 
    { 
        echo &quot;Correct password: FAIL\n&quot;; 
        $all_tests_pass = false; 
    } 
 
    // Same password doesn't create the same hash. 
    $hash2 = PasswordStorage::create_hash($correct_password); 
    if ($hash2 === $hash) { 
        echo &quot;Duplicate hashes: FAIL\n&quot;; 
        $all_tests_pass = false; 
    } else { 
        echo &quot;Duplicate hashes: pass\n&quot;; 
    } 
     
    // Wrong password returns false. 
    $result = PasswordStorage::verify_password(&quot;wrong_password&quot;, $hash); 
    if ($result === FALSE) 
    { 
        echo &quot;Wrong password: pass\n&quot;; 
    } 
    else 
    { 
        echo &quot;Wrong password: FAIL\n&quot;; 
        $all_tests_pass = false; 
    } 
     
    // Bad hash raises InvalidHashException 
    $raised = false; 
    try { 
        $result = PasswordStorage::verify_password(&quot;password&quot;, &quot;&quot;); 
    } catch (InvalidHashException $ex) { $raised = true; } 
    if ($raised) { 
        echo &quot;Bad hash: pass\n&quot;; 
    } else { 
        echo &quot;Bad hash: FAIL\n&quot;; 
        $all_tests_pass = false; 
    } 
 
    // Make sure truncated hashes don't verify. 
    $badHashLength = strlen($hash); 
    $truncateTest = true; 
 
    do { 
        $badHashLength -= 1; 
        $badHash = substr($hash, 0, $badHashLength); 
        $raised = false; 
        try { 
            $badResult = PasswordStorage::verify_password(&quot;correct_password&quot;, $badHash); 
        } catch (InvalidHashException $ex) { $raised = true; } 
 
        if (!$raised) { 
            echo &quot;Truncated hash test: FAIL &quot; .  
                &quot;(At hash length of &quot; . $badHashLength . &quot;) \n&quot;; 
 
            $truncateTest = false; 
            $all_tests_pass = false; 
            break; 
        }  
        // The loop goes on until it is two characters away from the last : it 
        // finds. This is because the PBKDF2 function requires a hash that's at 
        // least 2 characters long. This will be changed once exceptions are 
        // implemented. 
    } while ($badHash[$badHashLength - 3] != ':'); 
     
    if($truncateTest) { 
        echo &quot;Truncated hash test: pass\n&quot;; 
    } 
 
    // Make sure changing the algorithm breaks the hash. 
    $hash = PasswordStorage::create_hash(&quot;foobar&quot;); 
    $hash = str_replace(&quot;sha1:&quot;, &quot;sha256:&quot;, $hash); 
    // Here we don't expect an exception, since PHP does support SHA256, we 
    // just expect it to return false as though the password was wrong. 
    if (PasswordStorage::verify_password(&quot;foobar&quot;, $hash) === FALSE) { 
        echo &quot;Algorithm swap: pass\n&quot;; 
    } else { 
        echo &quot;Algorithm swap: FAIL\n&quot;; 
        $all_tests_pass = false; 
    } 
 
    // Make sure we reject invalid types. 
    try { 
        $bad = PasswordStorage::create_hash(array('test', 'lol', 'fail')); 
        echo &quot;Reject create_hash arrays: FAIL\n&quot;; 
        $all_tests_pass = false; 
    } catch (Exception $ex) { 
        echo &quot;Reject create_hash arrays: PASS\n&quot;; 
    } 
 
     
    // Make sure we reject invalid types. 
    try { 
        PasswordStorage::verify_password(array('test', 'lol', 'fail'), $hash); 
        echo &quot;Reject verify_password arrays: FAIL\n&quot;; 
        $all_tests_pass = false; 
    } catch (Exception $ex) { 
        echo &quot;Reject verify_password arrays: PASS\n&quot;; 
    } 
     
    return $all_tests_pass; 
} 
</span></pre>
</body>
</html>